CComQIPtr<IHTMLInputElement> pInputElem(phtmlElement);
if (pInputElem)
{
	pInputElem->get_checked(&varCheck.boolVal);
}

std::string KPI::ReportingPlanned()
{
	CHtmlTable htmlPlannedTable;
	std::string htmlPlannedTableHeader="Abbrev,Term, Description, Formula";
	htmlPlannedTable.SetHeaderColumns(htmlPlannedTableHeader);
	htmlPlannedTable.AddRows(htmlPlannedTableHeader, PlannedPeriods());
	return htmlPlannedTable.CreateHtmlTable();
}

std::string KPI::Reporting(Stats &factoryStats)
{	
	CHtmlTable htmlStatsPlannedTable;
	std::string htmlStatsPlannedTableHeader="Machine, OT, PSUT, PBT, PTU ";
	htmlStatsPlannedTable.SetHeaderColumns(htmlStatsPlannedTableHeader);
	std::string html = factoryStats.Property("name") + ",";
	html +=  ConvertToString(factoryStats["OT"]) + ",";
	html +=  ConvertToString(factoryStats["PSUT"]) + ",";
	html +=  ConvertToString(factoryStats["PBT"]) + ",";
	html +=  ConvertToString(factoryStats["PTU"]) ;
	htmlStatsPlannedTable.AddRow(htmlStatsPlannedTableHeader, html);

	return htmlStatsPlannedTable.CreateHtmlTable();
}	//for( boost::circular_buffer<EventType>::iterator it= Factory[i]->_statemachine->eventtrace.begin() ; it != Factory[i]->_statemachine->eventtrace.end(); ++it )


	// Unit operation (not resources) defintions
	//tmp+="OP, Operation process (AG)\n";
	//tmp+="OS, Operation sequence (AFO)\n";
	//tmp+="OT, Operation time (BZ)\n";

	//AUPT = AUP / nTotalParts;

//	tmp+="PU, Production unit (PE)\n";


	// inventory
	//tmp+="CI, Consumables inventory\n";
	//tmp+="FGI, Finished goods inventory\n";

	//tmp+="LLV, Lower limit value (UGW)\n";
	//tmp+="LT, Labor time (PZt)\n";
	//tmp+="PCT, Process time (BAZ)\n";
	//tmp+="PDT, Production time (HNZ)\n";
	//tmp+="PO, Production order (FA)\n";
	//tmp+="POQ, Production order quantity (FAM)\n";
	//tmp+="PRU, PlannedRunTimePerUnit \n";
	//tmp+="PSQ, Planned scrap quantity (GAM)\n";
	//tmp+="RMI, Raw material inventory\n";
	//tmp+="RQ, Rework quantity (NM)\n";
	//tmp+="s, Standard deviation\n";
	//tmp+="TAT, Total attendance time (GAZ)\n";
	//tmp+="TPT, Lead time / throughput time (DLZ)\n";
	//tmp+="TT, Transportation time (TZ)\n";
	//tmp+="ULV, Upper limit value (OGW)\n";
	//tmp+="WG, Working group (AGR)\n";
	//tmp+="WIP, Work in process inventory (WPI)\n";
	//tmp+="WOT, Working time (PAZ)\n";
	//tmp+="WP, Work place (AP)\n";
	//tmp+="WT, Wait time (LZ)\n";

(1) Conveyors including live roller, power & free, tow lines, belt conveyors, and monorails. 
(2) Storage Systems including conventional racks, high rise storage sys- 
tems, carousels, and flow racks. 
(3) Automatic Guided Vehicle Systems (AGVS) . 
(4) Industrial Trucks. 
(5) Machine Tools and Robots. 
(6) Cranes. 
(7) Flexible Manufacturing Systems. 
(8) Conventional Warehouses and Distribution Facilities. 


		// Good example specialized logging per Resource in FurLogger
		//CResourceHandler * resourceHandler= _resourceHandlers->Find("LINE1_PS_CAST1_FUR1");
		//if(resourceHandler!=NULL)
		//{
		//	//std::string dump;		
		//	//dump+= resourceHandler-> _statemachine->GenerateReport();
		//	//FurLogger.LogMessage(StdStringFormat("Resource(%s) Report=%s\n",resourceHandler->_identifier.c_str(), dump.c_str() ) );;
		//}

		//for(std::map<std::string, int > ::iterator it = finishedparts.begin() ; it!=finishedparts.end(); it++)
		//	OutputDebugString(StdStringFormat("END Total Number Parts %s =%d\n", ((*it).first).c_str(), finishedparts[(*it).first] ).c_str())  ;

// Correct.

MSG msg = { };
for (int i=0; PeekMessage(&msg, wndMain.m_hWnd, 0, 0))
{
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}
std::string CJobCommands::GenerateHtmlReport()
{
	CHtmlTable htmlTable; 
	std::string html = CHtmlTable::CreateHtmlSytlesheetFrontEnd("Precision Sand Casting Saginaw MI");;
	//html += htmlTable.HtmlGoogleChart(states);
	html += htmlTable.HtmlRaphaeleChart( );

	//html+= htmlTable.HtmlRaphaeleChartData(states );


	html += "</HEAD>\n";

	//std::string html = CHtmlTable()::CreateHtmlDocument();
	std::string header = "Machine," + Factory[0]->_statemachine->GenerateCSVHeader("Minutes") + ",Utility<BR>Costs</BR>,Description";
	std::string alignment = ",right,right,right,right,right,right,right,";
	htmlTable.SetAlignment(alignment);
	htmlTable.SetHeaderColumns( header);

	for(int i=0;i<Factory.size() ; i++)
	{
		std::string html1=Factory[i]->_statemachine->Name() + ","; ///???
		html1+= Factory[i]->_statemachine->GenerateCSVTiming(60.00) + "," ;
		html1+= Factory[i]->_statemachine->GenerateTotalCosts("","");
		html1+=  (LPCSTR) Factory[i]->_resource->description;
		htmlTable.AddRow(header, html1);
	}

	CHtmlTable htmlRawTable; 
	std::string headerRaw = "Machine,Blocked,Starved,Down,Production,Off";
	htmlRawTable.SetHeaderColumns( headerRaw);
	std::map<std::string,double> rawstates;
	for(int i=0;i<Factory.size() ; i++)
	{
		std::string html3;
		Factory[i]->_statemachine->GenerateStateReport(rawstates,1.0 );
		html3+=Factory[i]->_statemachine->Name() + ",";
		html3+=StdStringFormat("%8.4f,%8.4f,%8.4f,%8.4f,%8.4f\n",
			rawstates["blocked"],rawstates["starved"],rawstates["down"],rawstates["production"],rawstates["off"]);
		htmlRawTable.AddRows(headerRaw, html3);
	}

	CHtmlTable kpiTable; 
	std::string kpiheader = "Machine,MTBF,MTTR,INQ, OUTQ";
	kpiTable.SetHeaderColumns( kpiheader);
	for(int i=0;i<Factory.size() ; i++)
	{
		std::string machine=Factory[i]->_statemachine->Name() + ",";
		machine+= StdStringFormat("%8.4f,",Factory[i]->_statemachine->MTBF  );
		machine+= StdStringFormat("%8.4f,",Factory[i]->_statemachine->MTTR  );
		machine+= StdStringFormat("%d,",Factory[i]->_statemachine->MaxSize()  );
		kpiTable.AddRows(kpiheader, machine);
	}

	CHtmlTable htmlTable2; 
	std::string header2 = "Machine,Units,Name,State,Time,Cost";
	htmlTable2.SetHeaderColumns( header2);
	for(int i=0;i<Factory.size() ; i++)
	{
		std::string machine=Factory[i]->_statemachine->Name() + ",";
		std::string html2= Factory[i]->_statemachine->GenerateCosts(machine,"\n") ;
		htmlTable2.AddRows(header2, html2);
	}

	html+=	"<h1>Precision Casting</h1>\n";
	for(int i=0; i < this->at(0)->_cmsd->documentation->size(); i++)
		html+= "<p> " + UrlDecode (   (LPCSTR) ((Documentation *) this->at(0)->_cmsd->documentation->at(i).get())->description);
	html+=	"<p>\n";

	html += htmlRawTable.CreateHtmlTable();
	html+=	"<p>\n";
	html += kpiTable.CreateHtmlTable();


	html+=	"<h2>Casting Line 1 Performance</h2>\n";

	for( std::map<std::string, int >::iterator it = finishedparts.begin(); it!= finishedparts.end(); it++)
		html+=StdStringFormat("<BR> Part %s Number Made = %d\n" , (*it).first.c_str(), (*it).second).c_str();
	html+=	StdStringFormat("<br>Time elapsed %8.4f in hours\n", _dUpdateRateSec/3600.0);
	html+=	StdStringFormat("<br>Time elapsed %8.4f in minutes\n", _dUpdateRateSec/60.0);
	html+=	StdStringFormat("<br>Time elapsed %8.4f in seconds\n", _dUpdateRateSec);
	
	html += htmlTable.CreateHtmlTable();
	html+="<br>";
	html+=	"<h1>Casting Line 1 Utility Costs By Item</h1>\n";
	html += CHtmlTable::HtmlStateInfo();
	html+="<br>";
	html += htmlTable2.CreateHtmlTable();

	html+="<div id=\"holder\";\"></div>\n";
	//html +=" var chart = new google.visualization.PieChart(document.getElementById('chart_div'));\n";
	//html +=" chart.draw(data, options);\n";

		//////////////////////////////////////////////////////////////////////////
	// Make table of pie charts of performance states
	HtmlTableMaker Table(3);
	for(int i=0;i<Factory.size() ; i++)
	{
		std::string machine=Factory[i]->_statemachine->Name() + ",";
		std::map<std::string,double> states;
		Factory[i]->_statemachine->GenerateStateReport(states,1000.0 );;
		Table.AppendTableCell(Raphael::InlinePieChart(states, machine + " State Use"));
	}
	html+=Table.MakeTable();

	html+= "</BODY>\n</HTML>\n";

	WriteFile(::ExeDirectory() + "Doc.html", html);
	return html;
}


#include "url.h"
void __stdcall CWtlHtmlView::OnBeforeNavigate2 (
	IDispatch* pDisp, VARIANT* URL, VARIANT* Flags, VARIANT* TargetFrameName,
	VARIANT* PostData, VARIANT* Headers, VARIANT_BOOL* Cancel )
{
	// Return TRUE to cancel
	//*Cancel = VARIANT_FALSE;
	int i=0;
	Url url ((LPCSTR) bstr_t(URL));
	
	if(url._host == "localhost") //  
	{
		for(int i=0; i< listeners.size(); i++)
			listeners[i](url._path.c_str(), url.queries );

	}
	*Cancel = VARIANT_TRUE;
}

/////////////////////////////////////
		SINK_ENTRY_INFO(37, DIID_DWebBrowserEvents2, DISPID_COMMANDSTATECHANGE, OnCommandStateChange, &CommandStateChangeInfo)
	virtual void __stdcall OnCommandStateChange ( long lCmd, VARIANT_BOOL vbEnabled )
	{
		bool bFlag = (vbEnabled != VARIANT_FALSE);

		if ( CSC_NAVIGATEBACK == lCmd )
		{
			bBackEnable = bFlag;
			OutputDebugString(CString("OnCommandStateChange Back=%d\n" , bBackEnable));

		}
		else if ( CSC_NAVIGATEFORWARD == lCmd )
		{
			bForwardEnable = bFlag;
			OutputDebugString(CString("OnCommandStateChange Forward=%d\n" , bForwardEnable));
		}
	}



Optimization Goals:
·         sustainability goals
o   using less material and energy,
o   reducing waste, synonyms:  reduce non-value added activities,
o   recycling,
o   increasing workplace and product safety
o   consider alternative energy
o   more efficient use of necessary resources – energy, raw materials, human resources, information and equipment
o   reduce capital expenditures, for plant and office space and the energy to heat/cool them
o   schedules to accommodate off-peak hours
o   selling surplus energy back to the grid
o   not only using less material, but  providing better information how resource should be used.
o   different types of management needs for a variety of resources, such as energy, raw materials, water, air, gas, electricity and steam
o   supply chain improvement – reduce stock of raw materials and parts on hand of every kind needed to hedge against the risk of a shortage
o   improve spare part and scrap reordering tracking
o   higher income, lower cost, less use of tied-up capital and less work hazards
·         GM Goals – throughput, quality, energy, cost
 
Constraints:
·         Accuracy of data
·         Objectiveness of data (granularity and scope)
·         Adequate classification and categorization of data
·         Accessibility of data
·         Estimation of missing data
 
 
Collated list of analysis questions:
·         Can we reduce conveyor/transfer buffer sizes?
·         What is the bottleneck?
·         What is the yield - high, low, average?
·         What is the throughput - high, low, average?
·         Can we reduce the energy cost per state?
·         What is the energy cost per unit (energy yield) - high, low, average?
·         What is the economic cost per resource per unit? Per year output/per year costs - capital depreciation and maintenance?
·          
 
Those measurements with high/low values close together are not as prone to being improved, as the margin for success is small.
 
The foreseen scenario analysis includes:
·         Consider alternative energy
·         Correlate total energy consumption to parts produced per shift to develop a production energy yield.
·         Determine average and peak loads for given energy yield. Assess variability.
·         Compare energy yield against an equipment energy baseline determined from rated power to compute equipment energy sizing factor.
·         Compare daily variability of process energy consumption. Determine root cause in cases of high variability.
·         Compare energy consumption pre/post preventive maintenance. This scenario can assess operation when equipment and processes are expected to run efficiently.
·         Compare energy consumption between high and low scrap rate.
·         Compare yield to energy to outdoor temperature.
·         Adjust electrical cost to determine change in per unit cost.
·         Change fault times to determine change in electrical consumption.
·         Assess amount of equipment energy consumed versus rated power of equipment. Excessive powered equipment should be replaced with smaller equipment tailored to the specific needs of manufacturing cells.
·         Maximize electricity purchasing power, evaluate opportunities to reduce energy costs through load shifting of electricity use to off-peak times, assuming energy deregulation is applicable.
·         Determine if real-time power shedding to reduce the load and limit the peak load cost is required, compare to production efficiency, where high production efficiency correlated to minimal or no corresponding downtime, blocked or starved subprocesses, assuming the capability for power metering to predict the electrical demand.
 
 
OPTIMIZE WHAT?

Transport conveyor is used to model chain  and chain driven live roller conveyors.  These conveyors are characterized by long  drive sections with logical windows  larger than the pallet length. Induction  of a pallet onto the conveyor requires  that an empty window be exactly positioned in front of the induction location. All pallets on the conveyor are  physically locked together, the distance  between pallets cannot increase or  decrease. If the last pallet on the conveyor cannot advance then the conveyor  must stop and all loads behind the  stopped load will have an increased transit time. 

The difference between accumulation and  queuing conveyors has to do with the  movement of pallets from the conveyor  when multiple pallets are queued. In  accumulation conveyor when the first pallet in queue moves forward all pallets  behind also begin to move. However in queued conveyors the second pallet will not  advance until the first has moved one  pallet length forward. This creates the  effect an empty window rippling back  through the pallets in queue.


Down==Repair??

Fix each resource update time - what if starved - can't guess till not starved, ibid blocked

Job spawned - done job - better naming
Conveyor?  Handle as separate equipment or as part of resource with in/out queue
KPI cost functions
Hyperlink in description - UrlEncode/UrlDecode urldecode("http%3A%2F%2F");
Fox webview output, add single step, better queues plus item being services

 

	    <link rel="stylesheet" href="http://www.w3.org/StyleSheets/Core/Modernist" type="text/css">
	<link rel="stylesheet" href="simplify.css" media="all">

tmp +=	" <ul> \n";
	tmp +="<li>IDLE, STANDBY, and POWERUP, whose states are described by:</li> ";
	tmp +="<li>OFF the equipment being powered off.</li>";
	tmp +="<li> BUSY - the equipment power consumption where the manufacturing process is in an active state.</li>";
	 tmp +="<li>DOWN - the equipment power consumption in an alarm or fault state.</li>";
	tmp +=" <li>BLOCKED/STARVED – the state where the manufacturing process is inactive due to upstream";
	tmp +="downstream processing issues.</li>";
	tmp +="<li>IDLE - the equipment power consumption where the process is an inactive state. </li>";
	tmp +="<li>STANDBY - a reduced power consumption state, while the manufacturing process waits. </li>";
	tmp +="<li>POWERUP - the equipment power consumption while warming up.</li> ";
	tmp +=	" </ul> ";
	
	
	
	Cast Line 1 Double Deck Entry Upper Conveyor #1
Cast Line 1 Double Deck Entry Upper Conveyor #2
Cast Line 1 Double Deck Entry Lower Conveyor #1
Cast Line 1 Double Deck Entry Lower Conveyor #2

Cast Line 1 Lift-Locate Unit W/Stop


Cast Line 1 Outfeed Conveyor #1
Cast Line 1 Outfeed Conveyor #2
Cast Line 1 Outfeed Conveyor #3

Cast Line 1 Double Deck Outfeed Upper Conveyor #1
Cast Line 1 Double Deck Outfeed Upper Conveyor #2
Cast Line 1 Double Deck Outfeed Lower Conveyor #1
Cast Line 1 Double Deck Outfeed Lower Conveyor #2

Cast Line 1 Stuck Chill Reject Station


2013-04-25T17:39:00.0237Z: FATAL [2] Time elapsed 1867.0000
LINE1_PS_CAST1_ELV1 State starved Rate= 1.0000 In:0 Out:0 Job:3ab7a08 TTP= 8.3000
Blocked Time = 14.0000
Starved Time =1552.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2170.0000
Off Time = 0.0000
Name :'Upper Conveyor' State :any Time :0.415555 Cost :0.0457111
Name :'Lower Conveyor' State :any Time :0.415555 Cost :0.0457111
Name :'Upper Conveyor' State :faulted Time :0 Cost :0
LINE1_PS_CAST1_CRS1 State starved Rate= 1.0000 In:1 Out:0 Job:3aac750 TTP= 14.5000
Blocked Time = 16.0000
Starved Time =1636.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2084.0000
Off Time = 0.0000
LINE1_PS_CAST1_CI1 State running Rate= 1.0000 In:0 Out:0 Job:0 TTP= -0.5000
Blocked Time = 14.0000
Starved Time =1643.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2079.0000
Off Time = 0.0000
LINE1_PS_CAST1_AS1 State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= 0.0000
Blocked Time = 24.0000
Starved Time =1846.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =1865.0000
Off Time = 0.0000
LINE1_PS_CAST1_CVRDEL State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= 0.0000
Blocked Time = 24.0000
Starved Time =1846.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =1865.0000
Off Time = 0.0000
LINE1_PS_CAST1_CVS1 State running Rate= 1.0000 In:0 Out:0 Job:0 TTP= -0.8000
Blocked Time = 12.0000
Starved Time =1587.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2137.0000
Off Time = 0.0000
LINE1_PS_CAST1_LG1 State starved Rate= 1.0000 In:0 Out:0 Job:3aac750 TTP= 37.9000
Blocked Time = 14.0000
Starved Time =1644.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2078.0000
Off Time = 0.0000
LINE1_PS_CAST1_RO1 State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= 0.0000
Blocked Time = 24.0000
Starved Time =1846.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =1865.0000
Off Time = 0.0000
LINE1_PS_CAST1_FUR1 State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= 0.0000
Blocked Time = 24.0000
Starved Time =1846.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =1865.0000
Off Time = 0.0000
LINE1_PS_CAST1_EMP1 State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= 0.0000
Blocked Time = 24.0000
Starved Time =1687.0000
Down Time =160.0000
Repair Time =160.0000
Production Time =1706.0000
Off Time = 0.0000
LINE1_PS_CAST1_EG1 State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= -0.7000
Blocked Time = 14.0000
Starved Time =1652.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2070.0000
Off Time = 0.0000
LINE1_PS_CAST1_CE1 State starved Rate= 1.0000 In:0 Out:0 Job:0 TTP= 0.0000
Blocked Time = 14.0000
Starved Time =1604.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2118.0000
Off Time = 0.0000
LINE1_PS_CAST1_LWR1 State starved Rate= 1.0000 In:0 Out:0 Job:3aac750 TTP= 60.3000
Blocked Time = 14.0000
Starved Time =1667.0000
Down Time = 0.0000
Repair Time = 0.0000
Production Time =2055.0000
Off Time = 0.0000

Part Part1-12345= 10




6.1.2.10 CostAllocationData Class
The CostAllocationData class provides a means to specify information about the cost of performing a 
production activity or the cost for using a resource.
6.1.2.10.1 Defined Attributes and Association Roles
Attribute/Role 
Name Type Multiplicity Description
CostCategory CostCategory 0 to 1 A general category in which costs can be 
grouped.
CostType CostType 1
An indication of whether the cost is fixed 
or variable. 
CostName String 0 to 1 The name assigned to the cost item.
CostDescription String 0 to 1 A description of the cost item.
VariableCostData VariableCostData 0 to 1 Additional information about costs that 
are variable.
TotalCost CurrencyType 1
The total amount of money associated 
with this cost item.
Property Property 0 to *
Name and value information for a 
noteworthy characteristic associated with 
this cost item.


			// Sleep a second
			boost::xtime xt;
			boost::xtime_get(&xt, boost::TIME_UTC);
			xt.sec += _delay; 
			this->m_thread.sleep(xt);
			
			
			\begin{figure*}[htp]
\centering
\subfigure[CMSD Integrator]
{\includegraphics[width=6.0in]{./Pics/CMSDIntegrator.jpg}}
\subfigure[State Machine]
{\includegraphics[width=6.0in]{./Pics/blockprocessstarve.jpg}}
\end{figure*}


\begin{figure}[h]
\centering
\framebox{
{\includegraphics*[width=3.0inches]{./Pics/blockprocessstarve.jpg}
}

\caption{State Machine}
\label{fg:StateMachine} 
\end{figure}


C:\Program Files\NIST\proj\MTConnect\Nist\MTConnectGadgets\CMSDCommandCell\CMSDCommandCell\CmdCell.cpp

int CJobCommands::MaxQueueSize=2;

PS_CAST1_ELV1
PS_CAST1_CRS1
PS_CAST1_CI1
PS_CAST1_AS1
PS_CAST1_CVRDEL
PS_CAST1_CVS1
PS_CAST1_LG1
PS_CAST1_RO1
PS_CAST1_FUR1
PS_CAST1_EMP1
PS_CAST1_EG1
PS_CAST1_CE1
PS_CAST1_LWR1

SMCO_PS_CAST1_ELV1	Elevator 1
SMCO_PS_CAST1_CRS1	Package Insert 1 - CRS 1
SMCO_PS_CAST1_CI1	Chill Insert 1
SMCO_PS_CAST1_AS1	Alloy Addition 1
SMCO_PS_CAST1_CVRDEL	Cover Delivery 1
SMCO_PS_CAST1_CVS1	Cover Insert - CVS 1
SMCO_PS_CAST1_LG1	Load Gantry
SMCO_PS_CAST1_RO1	Rollover 1
SMCO_PS_CAST1_FUR1	Heated Well Furnace 1
SMCO_PS_CAST1_EMP1	EM Pump 1
SMCO_PS_CAST1_EG1	Exit Gantry
SMCO_PS_CAST1_CE1	Chill Extract 1
SMCO_PS_CAST1_LWR1	Lowerator 1

SMCO:LINE1_PS_CAST1_ELV1
SMCO:LINE1_PS_CAST1_CRS1
SMCO:LINE1_PS_CAST1_CI1
SMCO:LINE1_PS_CAST1_AS1
SMCO:LINE1_PS_CAST1_CVRDEL
SMCO:LINE1_PS_CAST1_CVS1
SMCO:LINE1_PS_CAST1_LG1
SMCO:LINE1_PS_CAST1_RO1
SMCO:LINE1_PS_CAST1_FUR1
SMCO:LINE1_PS_CAST1_EMP1
SMCO:LINE1_PS_CAST1_EG1
SMCO:LINE1_PS_CAST1_CE1
SMCO:LINE1_PS_CAST1_LWR1

	GLogger.AddListener( boost::bind(&CMainFrame::LogMsg, this, _1));
	GLogger.DebugString()=true;
	GLogger.Timestamping()=true;
	//GLogger.Open(::ExeDirectory() + "debug.txt");


//	This fixed(?) things:
	std::cout.rdbuf(&_outputdebugstream);
		std::cerr.rdbuf(&_outputdebugstream);



	//std::string dump;
	//dump += StdStringFormat("Time elapsed %8.4f\n", _dUpdateRateSec);
	//for(int i=0;i<_resourceHandlers.size() ; i++)
	//{
	////	dump+ _resourceHandlers[i]-> ToString();
	//	dump+= _resourceHandlers[i]-> GenerateReport();
	//	dump+= _resourceHandlers[i]->GenerateCosts();
	//}
	//dump+="\n";
	//for( std::map<std::string, int >::iterator it = finishedparts.begin(); it!= finishedparts.end(); it++)
	//	dump+=StdStringFormat("Part %s= %d\n" , (*it).first.c_str(), (*it).second).c_str();
	//GLogger << FATAL << dump << std::endl;
	//OutputDebugString(dump.c_str());





Simulation Engine Logic

The main loop of a discrete-event simulation is something like this:
[edit]Start
Initialize Ending Condition to FALSE.
Initialize system state variables.
Initialize Clock (usually starts at simulation time zero).
Schedule an initial event (i.e., put some initial event into the Events List).
[edit]“Do loop” or “While loop”
While (Ending Condition is FALSE) then do the following:
Set clock to next event time.
Do next event and remove from the Events List.
Update statistics.
[edit]End
Generate statistical report.

	/**
	ControlThread ct;
	ct.cycle();
	ct.cycle();
	ct.Trigger(init);
	ct.cycle();
	ct.SetStateTransition(ready,load, boost::bind(&Foo::Init1));
	ct.Trigger(load);
	ct.cycle();

ixme: add state transition listeners (or multiitem map)
			   		   */
#if 0
	class ControlThread;
		   	   	   class CState
	{
	public:
		const std::string off,ready,loaded,running,stopped,interrupted;
		const std::string faulted,finished,estopped,any, blocked, starved;
		CState() : 	off("off"), ready("ready"), loaded("loaded"), running("running"), stopped("stopped"),
			interrupted("interrupted"), faulted("faulted"), estopped("estopped"), any("any"), blocked("blocked"),
			starved("starved") {}
	};
	class CEvent
	{
	public:
		const std::string init,run,stop,hold,fail,reset;
		const std::string resume,done,quit,rewind,estop,step, block, starve, ok;
		CEvent() : ok("ok"),  init("init"), run("run"), stop("stop"), hold("hold"), fail("fail"),
			reset("reset"), resume("resume"), done("done"), quit("quit"),  rewind("rewind"), 
			estop("estop"), step("step"), block("block"), starve("starve"){}
	};
	__declspec(selectany)  CState State;
	__declspec(selectany)  CEvent Event;

#define GET_NAME(n) (#n)
#define PRINTABLE_ENUM_STRINGS 1
#include "PrintableEnum.h"
	ENUM(State, 0, (off) (ready) (loaded) (running) (stopped) (interrupted) (faulted) (finished)  (exit) (estopped) (any) (blocked) (starved) (stepping) (laststate))
		ENUM(Event, 0, (ok) (init) (load) (run) (stop) (hold) (fail) (reset) (resume)  (done) (quit) (rewind) (estop) (block) (starve) (step) (singlestep) (update))
		//typedef enum { off, ready, loaded, running, stopped, interrupted, faulted, finished,  exit, estopped, any} State;
		//typedef enum { init, load, run, stop, hold, fail, reset, resume, done, quit, rewind, estop} Event;

	typedef boost::tuple<int, int, int, ControlThreadCondFnc ,ControlNullThreadCondFnc  > StateMachineTuple;
#endif






	/*for(int i=0 ; i< _job->partIds.size(); i++)
	{
		parts.push_back( (LPCSTR) _job->partIds[i]);
		totnumparts.push_back(ConvertString<int>((LPCSTR)_job->partQuantity[i],1));
		numparts.push_back(0);
		finishedparts.push_back(0);
	}*/
	//int pi=0;
	
					if(jobs.Finished(pi))
					break;
				/*bool bFinished=true;
				int pn=pi%_job->partIds.size();
				for(int i=0; i< numparts.size(); i++)
					if(numparts[i]< totnumparts[i]) bFinished=false;

				if(bFinished)
				{
					break;
				}*/
				//bstr_t partid ;
				//if(numparts[pn]<totnumparts[pn])
				//{
				//	 partid = _job->partIds[pn];
				//	 numparts[pn]++;  // not actually done only will have to remove one when
				//}
				//else
				//{
				//	pi++; 
				//	continue;
				//}




				// You will need part id, *and* part instance - maybe assume 1:1 for now
				std::string aBody =  circle.GenerateXML(_qmr, (LPCSTR) vPartId );

				// 	<DataItem type="ASSET_CHANGED" id="BORE_1232" category="EVENT" name="BORE_1232"/>
				// THis will automatically be changed.
				//std::string aBody = "<Part><Inspection><MeasurementResults/></Inspection></Part>";
				std::string aId="BORE_1232";
				std::string type="Part";
				Device *device = _config->getAgent()->getDeviceByName(_device);

				_config->getAgent()->addAsset(device, aId, aBody, type);




c:\program files\nist\src\mtconnect\libagent\lib\dlib\md5\md5_kernel_1.h


  `groupname` char(30) NOT NULL DEFAULT '',
  `sectioninaccounts` int(11) NOT NULL DEFAULT '0',
  `pandl` tinyint(4) NOT NULL DEFAULT '1',
  `sequenceintb` smallint(6) NOT NULL DEFAULT '0',
  `parentgroupname` varchar(30) NOT NULL,

FXF 
http://www.seas.gwu.edu/~dorpjr/EMSE273/Session%206/11%20-%20Ch_05_ARENA.pdf

	CCmdEdit m_view;
		CString path;
		path.Format("tree /F /A \"%s\"\r\n", fldDlg.GetFolderPath());
		m_view.ProcessCommand(path);




   BOOL ScrollHtmlDocument2( 
        LPDISPATCH pdispDoc,      // The HTML document to scroll 
        BOOL bScroll)                     // TRUE=top;FALSE=bottom 
    { 
        CComQIPtr<IHTMLDocument2>piDoc(pdispDoc); 
        CComPtr<IHTMLWindow2>piWindow; 
        return (piDoc && SUCCEEDED(piDoc->get_parentWindow( 
            &piWindow)) && piWindow && SUCCEEDED(piWindow->scroll( 
                0, (bScroll) ? LONG_MIN : LONG_MAX))); 
    } 
And call it something like this... 
    // Some sort of handler function 
    void CMyHtmlView::OnScrollEnd() 
    { 
        if (LPDISPATCH pdispDoc = GetHtmlDocument()) 
        { 
            ScrollHtmlDocument2(pdispDoc, FALSE); 
            pdispDoc->Release(); 
        } 
    } 
#if 0
		_cmdAagentCfg.WriteCfgFile();
		//_agentcfg.Start();  // can just use the regular start of below, need to cofigure main?
		char *argv[4] = {
			"agent.exe",
			"debug",
			"" 
		};
		std::string file = _cfgfile; // change if not Agent.cfg
		argv[2]= new char[file.size() + 1]; 
		strcpy(argv[2], file.c_str()); 
		MTConnectService::main( 2,(const char **) argv);
#endif

#if 0
	CCMSDIntegrator cmsd;
	cmsd.ParseCMSD(::ExeDirectory() + "VirtualFactoryTestbed.xml");


	CCMSDAsset jobtracking;

	// Create new job with only one part from larger job
	Job * ajob= new Job();
	ajob->identifier = "job-1";
	ajob->partIds.push_back("Part1-12345");
	ajob->partQuantity.push_back("1");
	jobtracking.jobs->push_back(IObjectPtr((IObject *) ajob));

	// Part
	Part *  bpart = cmsd.FindPartById("Part1-12345");
	Part * apart = new Part();
	if(bpart!=NULL)
		apart->Copy(bpart);	
	jobtracking.parts->push_back(IObjectPtr((IObject *) bpart));

	// ProcessPlan
	ProcessPlan * plan = new ProcessPlan();
	plan = cmsd.FindProcessPlanById(bpart->processplanidentifier);	
	jobtracking.processplans->push_back(IObjectPtr((IObject *) plan));

	// Each cell for each process
	std::vector<bstr_t> steps = plan->steps;
	for(int i=0; i< steps.size(); i++)
	{
		Process* process = plan->FindProcess(steps[i]);
		if(process==NULL)
			continue;
		Cell * acell = cmsd.FindCellById((LPCSTR) process->resourcesRequired[0]);
		if(acell!=NULL)
			jobtracking.cells->push_back(IObjectPtr((IObject *) IObject::CreateCopy<Cell>(acell)));

		for(int j=0; j< acell->resourceIds.size(); j++)
		{
			Resource * equip = cmsd.FindResourceById(acell->resourceIds[j]);
			if(equip!=NULL)
				jobtracking.resources->push_back(IObjectPtr((IObject *) IObject::CreateCopy<Resource>(equip)));
		}
	}

	jobtracking.SaveCMSD(::ExeDirectory() + "Jobtracking.xml");
#endif


http://127.0.0.1/asset/asset_partprogram?
http://127.0.0.1/asset/asset_partprogram?type=PartProgram 

<?xml version="1.0" encoding="UTF-8" ?> 
- <MTConnectAssets xmlns:m="urn:mtconnect.org:MTConnectAssets:1.2" xmlns="urn:mtconnect.org:MTConnectAssets:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:mtconnect.org:MTConnectAssets:1.2 http://www.mtconnect.org/schemas/MTConnectAssets_1.2.xsd">
  <Header creationTime="2012-10-14T01:24:25Z" sender="mountaineer" instanceId="1350177582" version="1.2" assetBufferSize="1024" assetCount="1" /> 
  <Assets>now i lay me down</Assets> 
  </MTConnectAssets>
  
  		std::string aBody =  circle.GenerateXML(_qmr, (LPCSTR) vPartId );

				// 	<DataItem type="ASSET_CHANGED" id="BORE_1232" category="EVENT" name="BORE_1232"/>
				// THis will automatically be changed.
				//std::string aBody = "<Part><Inspection><MeasurementResults/></Inspection></Part>";
				std::string aId="BORE_1232";
				std::string type="Part";
				Device *device = _config->getAgent()->getDeviceByName(_device);

				_config->getAgent()->addAsset(device, aId, aBody, type);





				//Part* part = _cmsd->FindPartById( partid);
				//ProcessPlan * plan = new ProcessPlan();
				//*plan = *_cmsd->FindProcessPlanById(part->processplanidentifier);
				//plan->_pParentPart=part;
				//plan->currentStep =0;
				//plan->currentJobId = jobId++;
				//plan->jobId=(LPCSTR) partid;
				//plan->bActive=false;
				//currentprocessplans.push_back(plan);
				//OutputDebugString(StdStringFormat(" Start Job(%d) Part Parent=%s Plan =(%s)\n ", plan->currentJobId, (LPCSTR) plan->_pParentPart->identifier  ,  (LPCSTR)  plan->identifier).c_str());
				//GLogger << INFO << " Start Job(" << plan->currentJobId << ")" << "Part " << plan->_pParentPart->identifier  , plan->identifier ).c_str());
				


				//class CPartSequence
//{
//public:
//	std::string partnumber;
//	std::map<std::string, std::string> idmap;
//	//std::map<std::string, std::string>::iterator  PartProgram() { return idmap.find("command"); }
//	std::string & Command() { return idmap["command"]; } //idmap.find("command"); }
//	std::string & PartProgram() { return idmap["program"]; } //idmap.find("command"); }
//	std::string & PartNumber() { return idmap["partnumber"]; } 
//	CPartSequence(std::string program, std::string partid)
//	{
//		Command()="RUN";
//	}
//
//};



//class CCommand
//{
//public:
//	std::string partnumber;
//	std::map<std::string, std::string> idmap;
//	//std::map<std::string, std::string>::iterator  PartProgram() { return idmap.find("command"); }
//	std::string & Command() { return idmap["command"]; } //idmap.find("command"); }
//	std::string & PartProgram() { return idmap["program"]; } //idmap.find("command"); }
//	std::string & PartNumber() { return idmap["partnumber"]; } 
//	CCommand(std::string program, std::string partid)
//	{
//		idmap["command"]="RUN";
//	}
//
//};

//bool CResourceHandler::SendCommand(ProcessPlan * plan)
//{
//	boost::mutex::scoped_lock  lock(io_mutex);
//	if(!_inputprogram.empty())
//		return false;
//
//	this->_currentplan = plan;
//	plan->_pCurrentResource=this->_resource;
//
//	if(plan==NULL)
//		throw std::exception("CResourceHandler::SendCommand bad plan");
//
//	if(plan->currentStep< 0 || plan->currentStep >= plan->steps.size())
//		throw std::exception("CResourceHandler::SendCommand bad step in plan");
//
//	std::string program = (LPCSTR)  plan->PartProgram(plan->currentStep);
//	if(program.empty())
//	{
//		GLogger << FATAL << "CResourceHandler::SendCommand() No Program name" << std::endl; 
//
//		// Log error and continue
//		Reset();
//		if(_currentplan!=NULL) _currentplan->_currentState="DONE";
//		SetMTCTagValue(_device, "command", "RESET" );
//		SetMTCTagValue(_device, "cmdnum", StdStringFormat("%d",_nCmdnum++));
//
//	//throw std::exception("CResourceHandler::SendCommand bad program name");
//	}
//	_inputprogram=program;
//	//_partid=(LPCSTR) plan->_pParentPart->identifier;  //7 FIXME: _pParentPart points to nullish
//	_partid=plan->jobId;
//	return true;
//
//}



//int CCellHandler::Update()
//{
//	for(int i=0; i< _resources.size(); i++)
//	{
//		if(_resources[i]->IsIdle() && inprocessplans.size() > 0)
//		{
//			ProcessPlan * plan = inprocessplans.back();
//			bool bAccepted = _resources[i]->SendCommand(plan);
//			if(bAccepted)
//				inprocessplans.pop_back();
//		}
//		if(_resources[i]->IsDone() )
//		{
//			ProcessPlan * plan = _resources[i]->CurrentPlan();
//			if(plan==NULL)
//				return 0;
//			plan->currentStep++;
//			outprocessplans.push_back(plan);
//			_resources[i]->Reset();
//		}
//
//	}
//	return QueueSize();
//}


Line: Cast Line 1																
21-Feb-10-23-Mar-10(Daily--Shift 1)																
Exclude( Weekends Holidays Shift Breaks Partial TimeScale )																
(Partial Events)																
From Date	To Date	Machine Name	RunningTime	Downtime	BlockedTime	StarvedTime	ProductionTime	AverageCycleTime	RatedCycleTime	GoodParts	RejectParts	Jobs/Hour	MCBF	MTBF	MTTR	TotalCycleTime
			 (Minutes)	 (Minutes)	 (Minutes)	 (Minutes)	 (Minutes)	 (Seconds)	 (Seconds)	 (s)	 (s)	 (s)	 (s)	 (Minutes)	 (Minutes)	 (Minutes)
22-Feb-10	22-Feb-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
22-Feb-10	22-Feb-10	-Elevator 1	0	171.5	470	0.8	788.5	64.3	0	0	0	0	0	394.2	85.8	0
22-Feb-10	22-Feb-10	-Package 1	0	172.3	369	135.7	787.6	115.5	0	0	0	0	0	393.8	86.2	0
22-Feb-10	22-Feb-10	-Chill 1	0	172.4	386	81.7	787.6	64.5	0	0	0	0	0	393.8	86.2	0
22-Feb-10	22-Feb-10	-Alloy Addition 1	0	6.4	0	0	953.6	0	0	0	0	0	0	317.9	2.1	0
22-Feb-10	22-Feb-10	-Cover Delivery 1	0	16.8	0	0	266.3	0	0	0	0	0	0	266.3	16.8	0
22-Feb-10	22-Feb-10	-Cover 1	0	172.4	316	94.5	787.6	76.2	0	0	0	0	0	393.8	86.2	0
22-Feb-10	22-Feb-10	-Load Gantry	0	270.2	242	143.9	689.8	60.9	0	0	0	0	0	40.6	15.9	0
22-Feb-10	22-Feb-10	-Rollover 1	0	363.9	1	273.6	596.1	0	0	0	0	0	0	85.2	52	0
22-Feb-10	22-Feb-10	-Heated Well Furnace 1	0	0	0	0	600.4	0	0	0	0	0	0	0	0	0
22-Feb-10	22-Feb-10	-EM Pump 1	0	791	0	0	168.9	0	0	0	0	0	0	0.6	2.6	0
22-Feb-10	22-Feb-10	-Exit Gantry	0	270.2	1	362.5	689.8	65.3	0	0	0	0	0	40.6	15.9	0
22-Feb-10	22-Feb-10	-Chill Extract 1	0	173.5	0	405.8	786.5	76	0	0	0	0	0	262.2	57.8	0
22-Feb-10	22-Feb-10	-Lowerator 1	0	173	80	405.7	787	62.3	0	0	0	0	0	393.5	86.5	0
22-Feb-10	22-Feb-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
23-Feb-10	23-Feb-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
23-Feb-10	23-Feb-10	-Elevator 1	0	327.2	173	14.1	50.7	63.7	0	0	0	0	0	16.9	109.1	0
23-Feb-10	23-Feb-10	-Package 1	0	331.5	169	14.3	586.4	107.5	0	0	0	0	0	146.6	82.9	0
23-Feb-10	23-Feb-10	-Chill 1	0	331.5	166	10.5	586.4	64.9	0	0	0	0	0	146.6	82.9	0
23-Feb-10	23-Feb-10	-Alloy Addition 1	0	98.3	0	0	750.5	0	0	0	0	0	0	187.6	24.6	0
23-Feb-10	23-Feb-10	-Cover Delivery 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
23-Feb-10	23-Feb-10	-Cover 1	0	331.5	135	29.6	586.4	67.1	0	0	0	0	0	146.6	82.9	0
23-Feb-10	23-Feb-10	-Load Gantry	0	369.3	122	38.2	548.7	61.2	0	0	0	0	0	42.2	28.4	0
23-Feb-10	23-Feb-10	-Rollover 1	0	352.6	1	134.1	85.4	0	0	0	0	0	0	28.5	117.5	0
23-Feb-10	23-Feb-10	-Heated Well Furnace 1	0	0	0	0	904	0	0	0	0	0	0	0	0	0
23-Feb-10	23-Feb-10	-EM Pump 1	0	716.9	0	0	183.2	0	0	0	0	0	0	0.6	2.2	0
23-Feb-10	23-Feb-10	-Exit Gantry	0	369.3	0	141.9	548.7	64.7	0	0	0	0	0	42.2	28.4	0
23-Feb-10	23-Feb-10	-Chill Extract 1	0	332	0	207	106	60.7	0	0	0	0	0	26.5	83	0
23-Feb-10	23-Feb-10	-Lowerator 1	0	328	0	209.4	50	60.6	0	0	0	0	0	16.7	109.3	0
23-Feb-10	23-Feb-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
24-Feb-10	24-Feb-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
24-Feb-10	24-Feb-10	-Elevator 1	0	182.1	302	7.1	777.8	63	0	0	0	0	0	388.9	91	0
24-Feb-10	24-Feb-10	-Package 1	0	253.7	167	92	704.2	90.8	0	0	0	0	0	88	31.7	0
24-Feb-10	24-Feb-10	-Chill 1	0	253.6	136	64.8	704.2	68.7	0	0	0	0	0	88	31.7	0
24-Feb-10	24-Feb-10	-Alloy Addition 1	0	25.4	0	0	934.6	0	0	0	0	0	0	233.6	6.4	0
24-Feb-10	24-Feb-10	-Cover Delivery 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
24-Feb-10	24-Feb-10	-Cover 1	0	253.6	142	110.6	704.2	61.1	0	0	0	0	0	88	31.7	0
24-Feb-10	24-Feb-10	-Load Gantry	0	220.4	123	157	739.6	60.9	0	0	0	0	0	246.5	73.5	0
24-Feb-10	24-Feb-10	-Rollover 1	0	293	1	191.2	667	0	0	0	0	0	0	166.8	73.2	0
24-Feb-10	24-Feb-10	-Heated Well Furnace 1	0	0	0	0	900.7	0	0	0	0	0	0	0	0	0
24-Feb-10	24-Feb-10	-EM Pump 1	0	652.1	0	0	189	0	0	0	0	0	0	0.6	1.9	0
24-Feb-10	24-Feb-10	-Exit Gantry	0	220.4	6	255.9	739.6	64.1	0	0	0	0	0	246.5	73.5	0
24-Feb-10	24-Feb-10	-Chill Extract 1	0	186.5	0	301	773.5	62	0	0	0	0	0	257.8	62.2	0
24-Feb-10	24-Feb-10	-Lowerator 1	0	182.8	0	304	777.2	62.9	0	0	0	0	0	388.6	91.4	0
24-Feb-10	24-Feb-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
25-Feb-10	25-Feb-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
25-Feb-10	25-Feb-10	-Elevator 1	0	301.9	168	92.9	391	63.2	0	0	0	0	0	97.8	75.5	0
25-Feb-10	25-Feb-10	-Package 1	0	236.2	169	168	723.7	88.7	0	0	0	0	0	180.9	59	0
25-Feb-10	25-Feb-10	-Chill 1	0	236.3	170	162.5	723.7	62.9	0	0	0	0	0	180.9	59.1	0
25-Feb-10	25-Feb-10	-Alloy Addition 1	0	227.6	0	0	634	0	0	0	0	0	0	105.7	37.9	0
25-Feb-10	25-Feb-10	-Cover Delivery 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
25-Feb-10	25-Feb-10	-Cover 1	0	236.3	309	46.5	723.7	61.7	0	0	0	0	0	180.9	59.1	0
25-Feb-10	25-Feb-10	-Load Gantry	0	392.8	190	16.6	567.2	60.9	0	0	0	0	0	189.1	130.9	0
25-Feb-10	25-Feb-10	-Rollover 1	0	369.1	0	165	379.6	0	0	0	0	0	0	63.3	61.5	0
25-Feb-10	25-Feb-10	-Heated Well Furnace 1	0	0	0	0	848.9	0	0	0	0	0	0	0	0	0
25-Feb-10	25-Feb-10	-EM Pump 1	0	711.1	0	0	142.4	0	0	0	0	0	0	0.6	2.8	0
25-Feb-10	25-Feb-10	-Exit Gantry	0	392.8	1	189.1	567.2	64.5	0	0	0	0	0	189.1	130.9	0
25-Feb-10	25-Feb-10	-Chill Extract 1	0	301.2	0	267	654.4	66.5	0	0	0	0	0	163.6	75.3	0
25-Feb-10	25-Feb-10	-Lowerator 1	0	299.2	93	193	660.8	63.7	0	0	0	0	0	220.3	99.7	0
25-Feb-10	25-Feb-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
26-Feb-10	26-Feb-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
26-Feb-10	26-Feb-10	-Elevator 1	0	385	290	50.5	558	79.7	0	0	0	0	0	79.7	55	0
26-Feb-10	26-Feb-10	-Package 1	0	252.5	279	233.8	690.5	82.2	0	0	0	0	0	115.1	42.1	0
26-Feb-10	26-Feb-10	-Chill 1	0	252.5	285	230	690.5	65	0	0	0	0	0	115.1	42.1	0
26-Feb-10	26-Feb-10	-Alloy Addition 1	0	2.4	0	0	700.7	0	0	0	0	0	0	700.7	2.4	0
26-Feb-10	26-Feb-10	-Cover Delivery 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
26-Feb-10	26-Feb-10	-Cover 1	0	252.5	207	320.8	690.5	60.5	0	0	0	0	0	115.1	42.1	0
26-Feb-10	26-Feb-10	-Load Gantry	0	255	292	233.1	688	60.1	0	0	0	0	0	98.3	36.4	0
26-Feb-10	26-Feb-10	-Rollover 1	0	304.7	0	397.1	638.3	0	0	0	0	0	0	106.4	50.8	0
26-Feb-10	26-Feb-10	-Heated Well Furnace 1	0	0	0	0	957.1	0	0	0	0	0	0	0	0	0
26-Feb-10	26-Feb-10	-EM Pump 1	0	794.6	0	0	88.5	0	0	0	0	0	0	0.5	4.8	0
26-Feb-10	26-Feb-10	-Exit Gantry	0	255	29	483.5	688	64.5	0	0	0	0	0	98.3	36.4	0
26-Feb-10	26-Feb-10	-Chill Extract 1	0	272.7	0	482.3	670.4	67.9	0	0	0	0	0	67	27.3	0
26-Feb-10	26-Feb-10	-Lowerator 1	0	254.5	65	455	688.5	61	0	0	0	0	0	114.8	42.4	0
26-Feb-10	26-Feb-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
01-Mar-10	01-Mar-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
01-Mar-10	01-Mar-10	-Elevator 1	0	172.9	399	0.6	787.1	63.5	0	0	0	0	0	262.4	57.6	0
01-Mar-10	01-Mar-10	-Package 1	0	173	394	10.8	787	100.8	0	0	0	0	0	262.3	57.7	0
01-Mar-10	01-Mar-10	-Chill 1	0	173.1	378	8.4	786.9	65.9	0	0	0	0	0	262.3	57.7	0
01-Mar-10	01-Mar-10	-Alloy Addition 1	0	1.7	0	0	925	0	0	0	0	0	0	462.5	0.8	0
01-Mar-10	01-Mar-10	-Cover Delivery 1	0	155.4	0	0	804.6	0	0	0	0	0	0	804.6	155.4	0
01-Mar-10	01-Mar-10	-Cover 1	0	173.1	229	175.1	786.9	63	0	0	0	0	0	262.3	57.7	0
01-Mar-10	01-Mar-10	-Load Gantry	0	173.3	246	165.8	786.7	61.1	0	0	0	0	0	262.2	57.8	0
01-Mar-10	01-Mar-10	-Rollover 1	0	298.5	0	243.1	566.2	0	0	0	0	0	0	94.4	49.8	0
01-Mar-10	01-Mar-10	-Heated Well Furnace 1	0	0	0	0	403	0	0	0	0	0	0	0	0	0
01-Mar-10	01-Mar-10	-EM Pump 1	0	666.7	0	0	138.6	0	0	0	0	0	0	0.6	2.7	0
01-Mar-10	01-Mar-10	-Exit Gantry	0	173.3	60	340	786.7	64	0	0	0	0	0	262.2	57.8	0
01-Mar-10	01-Mar-10	-Chill Extract 1	0	224.6	3	324.3	735.4	66.3	0	0	0	0	0	61.3	18.7	0
01-Mar-10	01-Mar-10	-Lowerator 1	0	184.2	35	350.2	775.8	64.8	0	0	0	0	0	194	46	0
01-Mar-10	01-Mar-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
02-Mar-10	02-Mar-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
02-Mar-10	02-Mar-10	-Elevator 1	0	0	385	2	796.2	64.3	0	0	0	0	0	0	0	0
02-Mar-10	02-Mar-10	-Package 1	0	0.2	388	8.4	795.9	90.5	0	0	0	0	0	795.9	0.2	0
02-Mar-10	02-Mar-10	-Chill 1	0	0.2	354	2.5	795.9	69.7	0	0	0	0	0	795.9	0.2	0
02-Mar-10	02-Mar-10	-Alloy Addition 1	0	20.5	0	0	939.5	0	0	0	0	0	0	156.6	3.4	0
02-Mar-10	02-Mar-10	-Cover Delivery 1	0	5.6	0	0	954.4	0	0	0	0	0	0	954.4	5.6	0
02-Mar-10	02-Mar-10	-Cover 1	0	0.2	131	287.7	795.9	60.3	0	0	0	0	0	795.9	0.2	0
02-Mar-10	02-Mar-10	-Load Gantry	0	10	155	246.4	776.6	60.6	0	0	0	0	0	388.3	5	0
02-Mar-10	02-Mar-10	-Rollover 1	0	65.5	0	324.1	702.7	0	0	0	0	0	0	351.4	32.8	0
02-Mar-10	02-Mar-10	-Heated Well Furnace 1	0	0	0	0	933.3	0	0	0	0	0	0	0	0	0
02-Mar-10	02-Mar-10	-EM Pump 1	0	562.3	0	0	194.2	0	0	0	0	0	0	0.6	1.6	0
02-Mar-10	02-Mar-10	-Exit Gantry	0	10	0	372.9	776.6	65.4	0	0	0	0	0	388.3	5	0
02-Mar-10	02-Mar-10	-Chill Extract 1	0	0	0	430.6	795.9	63.4	0	0	0	0	0	0	0	0
02-Mar-10	02-Mar-10	-Lowerator 1	0	0	19	428.8	795.8	60.9	0	0	0	0	0	0	0	0
02-Mar-10	02-Mar-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
03-Mar-10	03-Mar-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
03-Mar-10	03-Mar-10	-Elevator 1	0	167.8	374	26.8	792.2	63.7	0	0	0	0	0	396.1	83.9	0
03-Mar-10	03-Mar-10	-Package 1	0	174.7	371	13.4	785.3	84.9	0	0	0	0	0	261.8	58.2	0
03-Mar-10	03-Mar-10	-Chill 1	0	174.7	365	24.5	785.3	64.5	0	0	0	0	0	261.8	58.2	0
03-Mar-10	03-Mar-10	-Alloy Addition 1	0	126.6	0	0	833.4	0	0	0	0	0	0	75.8	11.5	0
03-Mar-10	03-Mar-10	-Cover Delivery 1	0	209.5	0	0	54.6	0	0	0	0	0	0	54.6	209.5	0
03-Mar-10	03-Mar-10	-Cover 1	0	174.7	210	191.3	785.3	62.4	0	0	0	0	0	261.8	58.2	0
03-Mar-10	03-Mar-10	-Load Gantry	0	168.3	239	177.7	791.7	61	0	0	0	0	0	395.8	84.2	0
03-Mar-10	03-Mar-10	-Rollover 1	0	268.8	0	297.3	691.2	0	0	0	0	0	0	172.8	67.2	0
03-Mar-10	03-Mar-10	-Heated Well Furnace 1	0	0	0	0	939.9	0	0	0	0	0	0	0	0	0
03-Mar-10	03-Mar-10	-EM Pump 1	0	752.1	0	0	208	0	0	0	0	0	0	0.6	2	0
03-Mar-10	03-Mar-10	-Exit Gantry	0	168.3	0	394.4	791.7	64.6	0	0	0	0	0	395.8	84.2	0
03-Mar-10	03-Mar-10	-Chill Extract 1	0	168.6	1	411.2	791.3	61.7	0	0	0	0	0	395.6	84.3	0
03-Mar-10	03-Mar-10	-Lowerator 1	0	169.6	30	392	790.4	60.6	0	0	0	0	0	395.2	84.8	0
03-Mar-10	03-Mar-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
04-Mar-10	04-Mar-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
04-Mar-10	04-Mar-10	-Elevator 1	0	198.1	305	48.7	741.6	62.8	0	0	0	0	0	185.4	49.5	0
04-Mar-10	04-Mar-10	-Package 1	0	214.2	193	100	672.3	81.6	0	0	0	0	0	96	30.6	0
04-Mar-10	04-Mar-10	-Chill 1	0	214.2	255	20.4	672.3	63.4	0	0	0	0	0	96	30.6	0
04-Mar-10	04-Mar-10	-Alloy Addition 1	0	266.3	0	0	604.1	0	0	0	0	0	0	60.4	26.6	0
04-Mar-10	04-Mar-10	-Cover Delivery 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
04-Mar-10	04-Mar-10	-Cover 1	0	214.2	209	76.9	672.3	61	0	0	0	0	0	96	30.6	0
04-Mar-10	04-Mar-10	-Load Gantry	0	216.4	213	132.7	727.6	60.8	0	0	0	0	0	145.5	43.3	0
04-Mar-10	04-Mar-10	-Rollover 1	0	265	2	221	670.4	0	0	0	0	0	0	223.5	88.3	0
04-Mar-10	04-Mar-10	-Heated Well Furnace 1	0	0	0	0	799.2	0	0	0	0	0	0	0	0	0
04-Mar-10	04-Mar-10	-EM Pump 1	0	655.3	0	0	184.1	0	0	0	0	0	0	0.5	2	0
04-Mar-10	04-Mar-10	-Exit Gantry	0	216.4	38	288.8	727.6	63.8	0	0	0	0	0	145.5	43.3	0
04-Mar-10	04-Mar-10	-Chill Extract 1	0	248.2	2	285.6	691.3	63.7	0	0	0	0	0	138.3	49.6	0
04-Mar-10	04-Mar-10	-Lowerator 1	0	250.1	12	281.1	689.4	64	0	0	0	0	0	172.4	62.5	0
04-Mar-10	04-Mar-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
05-Mar-10	05-Mar-10	-Cast Buffer 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
05-Mar-10	05-Mar-10	-Elevator 1	0	161.2	342	8.2	798.8	63.3	0	0	0	0	0	798.8	161.2	0
05-Mar-10	05-Mar-10	-Package 1	0	174.8	297	45.9	785.2	78.5	0	0	0	0	0	261.7	58.3	0
05-Mar-10	05-Mar-10	-Chill 1	0	174.8	294	42.2	785.2	63.8	0	0	0	0	0	261.7	58.3	0
05-Mar-10	05-Mar-10	-Alloy Addition 1	0	18.1	0	0	941.8	0	0	0	0	0	0	188.4	3.6	0
05-Mar-10	05-Mar-10	-Cover Delivery 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0
05-Mar-10	05-Mar-10	-Cover 1	0	174.8	144	209.8	785.2	60.7	0	0	0	0	0	261.7	58.3	0
05-Mar-10	05-Mar-10	-Load Gantry	0	161.4	182	182.1	798.6	60.5	0	0	0	0	0	798.6	161.4	0
05-Mar-10	05-Mar-10	-Rollover 1	0	232	0	194.6	522.6	0	0	0	0	0	0	104.5	46.4	0
05-Mar-10	05-Mar-10	-Heated Well Furnace 1	0	0	0	0	920.7	0	0	0	0	0	0	0	0	0
05-Mar-10	05-Mar-10	-EM Pump 1	0	660.2	0	0	204.2	0	0	0	0	0	0	0.6	1.8	0
05-Mar-10	05-Mar-10	-Exit Gantry	0	161.4	12	332.9	798.6	63.9	0	0	0	0	0	798.6	161.4	0
05-Mar-10	05-Mar-10	-Chill Extract 1	0	171.9	0	336.2	788.1	64.5	0	0	0	0	0	394	86	0
05-Mar-10	05-Mar-10	-Lowerator 1	0	162.2	31	337.6	797.8	63.4	0	0	0	0	0	797.8	162.2	0
05-Mar-10	05-Mar-10	-Overall Cast Line 1	0	0	0	0	0	0	0	0	0	0	0	0	0	0



			Customer: GM - SMCO				REFERENCE:  	10-24360-001-117  GROUND FLOOR																					
			Vulcan Project # 24360					10-24360-001-40  MEZZANINE																					
			Date: June 11, 2004					10-24360-106-32  BASEMENT																					
			Rev No.	7																									
A	B	C	D	E	F	G	H	I	J	K	L	M	N	O	P	Q	R	S	T	U	V	W	X	Y	AA	AB	AC	AD	AE
		PRELIMINARY ESTIMATE	Utility Consumption																										
		CAST LINES	Electrical							NOTE 2	Natural Gas			Water				Hydraulics				Air				Tea Piping	Resin Piping	Steam	Pattern Spray
Row	Rev	Equipment Description	Voltage	HP	"Motor
kW"	"Load
kW"	kVA	"Demand
Factor"	"Demand
kVA"	Circuit Size	PSI	CFM	Size	City GPM	Plant GPM	Chilled GPM	Size	Unit	PSI	GPM	Size	Dry CFM	Plant CFM	PSI	Size				
		#1 LINE																											
10		Cast Line 1 Entry Elevator Upper Conveyor	480	1			1	0.8	0.8											0								0	
11		Cast Line 1 Entry Elevator Lower Conveyor	480	1			1	0.8	0.8											0								0	
12	7	Cast Line 1 Entry Elevator Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
13	7	Cast Line 1 Entry Elevator Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
14																													
15		Cast Line 1 Double Deck Entry Upper Conveyor #1	480	1			1	0.8	0.8											0								0	
16		Cast Line 1 Double Deck Entry Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
17		Cast Line 1 Double Deck Entry Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
18		Cast Line 1 Double Deck Entry Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
19																													
20		Cast Line 1 Lift-Locate Unit W/Stop	480	0.75			0.75	0.8	0.6											0			5	60	1/2 NPT			0	
21																							15	60	1/2 NPT				
22		Cast Line 1 Chill Insert Station Upper Elevator Conveyor	480	1			1	0.8	0.8											0								0	
23		Cast Line 1 Chill Insert Station Lower Elevator Conveyor	480	1			1	0.8	0.8											0								0	
24		Cast Line 1 Chill Insert Station Exit Conveyor W/Blow Off	480	1			1	0.8	0.8											0		155		60	1 NPT			0	
25		Cast Line 1 Chill Insert Station Hydraulic Unit Pump	480	75			75	0.8	60.0										1500	75								0	
26	7	Cast Line 1 Chill Insert Station Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
27																													
28		Cast Line 1 Cover Insertion Infeed Conveyor	480	1			1	0.8	0.8											0								0	
29		Cast Line 1 Cover Insertion Insertion Conveyor	480	1			1	0.8	0.8											0								0	
30		Cast Line 1 Cover Insertion Exit Conveyor	480	1			1	0.8	0.8											0								0	
31																													
32	7	Cast Line 1 Load Grantry X-Axis Travel	480	1			1	0.8	0.8											0								0	
33	7	Cast Line 1 Load Grantry Y-Axis Travel	480	25			25	0.8	20.0											0								0	
34	7	Cast Line 1 Unload Grantry X-Axis Travel	480	1			1	0.8	0.8											0								0	
35	7	Cast Line 1 Unload Grantry Y-Axis Travel	480	25			25	0.8	20.0											0								0	
36	7	Cast Line 1 Load/Unload Grantry Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
37	7	Cast Line 1 Load/Unload Grantry Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
38																													
39		Cast Line 1 Outfeed Conveyor #1	480	1			1	0.8	0.8											0								0	
40		Cast Line 1 Outfeed Conveyor #2	480	1			1	0.8	0.8											0								0	
41		Cast Line 1 Outfeed Conveyor #3	480	1			1	0.8	0.8											0								0	
42																							15	60	1/2 NPT				
43		Cast Line 1 Chill Extraction Station Inlet Conveyor	480	1			1	0.8	0.8											0			5	60	1/2 NPT			0	
44		Cast Line 1 Chill Extraction Station Upper Elevator Conveyor	480	1			1	0.8	0.8											0								0	
45		Cast Line 1 Chill Extraction Station Lower Elevator Conveyor	480	1			1	0.8	0.8											0								0	
46		Cast Line 1 Chill Extraction Station Hydraulic Unit Pump	480	75			75	0.8	60.0										1500	75								0	
47		Cast Line 1 Chill Extraction Station Hyd. Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
48																													
49		Cast Line 1 Double Deck Outfeed Upper Conveyor #1	480	1			1	0.8	0.8											0								0	
50		Cast Line 1 Double Deck Outfeed Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
51		Cast Line 1 Double Deck Outfeed Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
52		Cast Line 1 Double Deck Outfeed Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
53																													
54		Cast Line 1 Stuck Chill Reject Station	480	0.75			0.75	0.8	0.6											0								0	
55	7	Cast Line 1 Double Deck Exit Upper Conveyor #1	480	1			1	0.8	0.8																				
56	7	Cast Line 1 Double Deck Exit Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
57	7	Cast Line 1 Double Deck Exit Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
58	7	Cast Line 1 Double Deck Exit Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
59	7	Cast Line 1 Exit Elevator Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
60	7	Cast Line 1 Exit Elevator Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15													
61	6	Cast Line 1 Rollover Main Panel	480							100																			
61A	6	Cast Line 1 Rollover Index Table	480	5			5	0.8	4.0																				
61B	6	Cast Line 1 Rollover Hydraulic Motor #1	480	15			15	0.8	12.0																				
61C	6	Cast Line 1 Rollover Hydraulic Motor #2	480	15			15	0.8	12.0																				
61D	6	Cast Line 1 Rollover Recirc Pump	480	1			1	0.8	0.8																				
61E	6	Cast Line 1 EM Pump Preheat Oven	480	1			1	0.8	0.8																				
61F	6	Cast Line 1 EM Pump Cooling Fan Control Panel	480							176																			
61G	6	Cast Line 1 EM Pump Cooling Motor #1	480	1			1	0.8	0.8																				
61H	6	Cast Line 1 EM Pump Cooling Motor #2	480	1			1	0.8	0.8																				
61I	6	Cast Line 1 EM Pump Main Control Panel	480							700																			
62																													
63		#2 LINE																											
64		Cast Line 2 Entry Elevator Upper Conveyor	480	1			1	0.8	0.8											0								0	
65		Cast Line 2 Entry Elevator Lower Conveyor	480	1			1	0.8	0.8											0								0	
66	7	Cast Line 2 Entry Elevator Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
67	7	Cast Line 2 Entry Elevator Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
68																													
69		Cast Line 2 Double Deck Entry Upper Conveyor #1	480	1			1	0.8	0.8											0								0	
70		Cast Line 2 Double Deck Entry Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
71		Cast Line 2 Double Deck Entry Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
72		Cast Line 2 Double Deck Entry Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
73																													
74		Cast Line 2 Lift-Locate Unit W/Stop	480	0.75			0.75	0.8	0.6											0			5	60	1/2 NPT			0	
75																							15	60	1/2 NPT				
76		Cast Line 2 Chill Insert Station Upper Elevator Conveyor	480	1			1	0.8	0.8											0								0	
77		Cast Line 2 Chill Insert Station Lower Elevator Conveyor	480	1			1	0.8	0.8											0								0	
78		Cast Line 2 Chill Insert Station Exit Conveyor W/Blow Off	480	1			1	0.8	0.8											0		155		60	1 NPT			0	
79		Cast Line 2 Chill Insert Station Hydraulic Unit Pump	480	75			75	0.8	60.0										1500	75								0	
80	7	Cast Line 2 Chill Insert Station Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
81																													
82		Cast Line 2 Cover Insertion Infeed Conveyor	480	1			1	0.8	0.8											0								0	
83		Cast Line 2 Cover Insertion Insertion Conveyor	480	1			1	0.8	0.8											0								0	
84		Cast Line 2 Cover Insertion Exit Conveyor	480	1			1	0.8	0.8											0								0	
85																													
86	7	Cast Line 2 Load Grantry X-Axis Travel	480	1			1	0.8	0.8											0								0	
87	7	Cast Line 2 Load Grantry Y-Axis Travel	480	25			25	0.8	20.0											0								0	
88	7	Cast Line 2 Unload Grantry X-Axis Travel	480	1			1	0.8	0.8											0								0	
89	7	Cast Line 2 Unload Grantry Y-Axis Travel	480	25			25	0.8	20.0											0								0	
90	7	Cast Line 2 Load/Unload Grantry Hydraulic Unit Pump	480	50			50	0.8	40.0							15			1500	75								0	
91	7	Cast Line 2 Load/Unload Grantry Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4											0								0	
92																													
93		Cast Line 2 Outfeed Conveyor #1	480	1			1	0.8	0.8											0								0	
94		Cast Line 2 Outfeed Conveyor #2	480	1			1	0.8	0.8											0								0	
95		Cast Line 2 Outfeed Conveyor #3	480	1			1	0.8	0.8											0								0	
96																							15	60	1/2 NPT				
97		Cast Line 2 Chill Extraction Station Inlet Conveyor	480	1			1	0.8	0.8											0			5	60	1/2 NPT			0	
98		Cast Line 2 Chill Extraction Station Upper Elevator Conveyor	480	1			1	0.8	0.8											0								0	
99		Cast Line 2 Chill Extraction Station Lower Elevator Conveyor	480	1			1	0.8	0.8											0								0	
100		Cast Line 2 Chill Extraction Station Hydraulic Unit Pump	480	75			75	0.8	60.0										1500	75								0	
101		Cast Line 2 Chill Extraction Station Hyd. Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
102																													
103		Cast Line 2 Double Deck Outfeed Upper Conveyor #1	480	1			1	0.8	0.8											0								0	
104		Cast Line 2 Double Deck Outfeed Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
105		Cast Line 2 Double Deck Outfeed Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
106		Cast Line 2 Double Deck Outfeed Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
107																													
108		Cast Line 2 Stuck Chill Reject Station	480	0.75			0.75	0.8	0.6											0								0	
109	7	Cast Line 2 Double Deck Exit Upper Conveyor #1	480	1			1	0.8	0.8																				
110	7	Cast Line 2 Double Deck Exit Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
111	7	Cast Line 2 Double Deck Exit Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
112	7	Cast Line 2 Double Deck Exit Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
113	7	Cast Line 2 Exit Elevator Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
114	7	Cast Line 2 Exit Elevator Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15													
114A	6	Cast Line 1 Rollover Main Panel	480							100																			
114B	6	Cast Line 1 Rollover Index Table	480	5			5	0.8	4.0																				
114C	6	Cast Line 1 Rollover Hydraulic Motor #1	480	15			15	0.8	12.0																				
114D	6	Cast Line 1 Rollover Hydraulic Motor #2	480	15			15	0.8	12.0																				
114E	6	Cast Line 1 Rollover Recirc Pump	480	1			1	0.8	0.8																				
114F	6	Cast Line 1 EM Pump Preheat Oven	480	1			1	0.8	0.8																				
114G	6	Cast Line 1 EM Pump Cooling Fan Control Panel	480							176																			
114H	6	Cast Line 1 EM Pump Cooling Motor #1	480	1			1	0.8	0.8																				
114I	6	Cast Line 1 EM Pump Cooling Motor #2	480	1			1	0.8	0.8																				
114J	6	Cast Line 1 EM Pump Main Control Panel	480							700																			
115																													
116		#3 LINE																											
117		Cast Line 3 Entry Elevator Upper Conveyor	480	1			1	0.8	0.8											0								0	
118		Cast Line 3 Entry Elevator Lower Conveyor	480	1			1	0.8	0.8											0								0	
119	7	Cast Line 3 Entry Elevator Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
120	7	Cast Line 3 Entry Elevator Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
121																													
122		Cast Line 3 Double Deck Entry Upper Conveyor #1	480	1			1	0.8	0.8											0								0	
123		Cast Line 3 Double Deck Entry Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
124		Cast Line 3 Double Deck Entry Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
125		Cast Line 3 Double Deck Entry Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
126																													
127		Cast Line 3 Lift-Locate Unit W/Stop	480	0.75			0.75	0.8	0.6											0			5	60	1/2 NPT			0	
128																							15	60	1/2 NPT				
129		Cast Line 3 Chill Insert Station Upper Elevator Conveyor	480	1			1	0.8	0.8											0								0	
130		Cast Line 3 Chill Insert Station Lower Elevator Conveyor	480	1			1	0.8	0.8											0								0	
131		Cast Line 3 Chill Insert Station Exit Conveyor W/Blow Off	480	1			1	0.8	0.8											0		155		60	1 NPT			0	
132		Cast Line 3 Chill Insert Station Hydraulic Unit Pump	480	75			75	0.8	60.0										1500	75								0	
133		Cast Line 3 Chill Insert Station Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
134																													
135		Cast Line 3 Cover Insertion Infeed Conveyor	480	1			1	0.8	0.8											0								0	
136		Cast Line 3 Cover Insertion Insertion Conveyor	480	1			1	0.8	0.8											0								0	
137		Cast Line 3 Cover Insertion Exit Conveyor	480	1			1	0.8	0.8											0								0	
138																													
139	7	Cast Line 3 Load Grantry X-Axis Travel	480	1			1	0.8	0.8											0								0	
140	7	Cast Line 3 Load Grantry Y-Axis Travel	480	25			25	0.8	20.0											0								0	
141	7	Cast Line 3 Unload Grantry X-Axis Travel	480	1			1	0.8	0.8											0								0	
142	7	Cast Line 3 Unload Grantry Y-Axis Travel	480	25			25	0.8	20.0											0								0	
143	7	Cast Line 3 Load/Unload Grantry Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
144	7	Cast Line 3 Load/Unload Grantry Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
145																													
146		Cast Line 3 Outfeed Conveyor #1	480	1			1	0.8	0.8											0								0	
147		Cast Line 3 Outfeed Conveyor #2	480	1			1	0.8	0.8											0								0	
148		Cast Line 3 Outfeed Conveyor #3	480	1			1	0.8	0.8											0								0	
149																							15	60	1/2 NPT				
150		Cast Line 3 Chill Extraction Station Inlet Conveyor	480	1			1	0.8	0.8											0			5	60	1/2 NPT			0	
151		Cast Line 3 Chill Extraction Station Upper Elevator Conveyor	480	1			1	0.8	0.8											0								0	
152		Cast Line 3 Chill Extraction Station Lower Elevator Conveyor	480	1			1	0.8	0.8											0								0	
153		Cast Line 3 Chill Extraction Station Hydraulic Unit Pump	480	75			75	0.8	60.0										1500	75								0	
154	7	Cast Line 3 Chill Extraction Station Hyd. Unit Recirc Pump	480	3			3	0.8	2.4							15				0								0	
155																													
156		Cast Line 3 Double Deck Outfeed Upper Conveyor #1	480	1			1	0.8	0.8											0								0	
157		Cast Line 3 Double Deck Outfeed Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
158		Cast Line 3 Double Deck Outfeed Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
159		Cast Line 3 Double Deck Outfeed Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
160																													
161		Cast Line 3 Stuck Chill Reject Station	480	0.75			0.75	0.8	0.6											0								0	
162	7	Cast Line 3 Double Deck Exit Upper Conveyor #1	480	1			1	0.8	0.8																				
163	7	Cast Line 3 Double Deck Exit Upper Conveyor #2	480	1			1	0.8	0.8											0								0	
164	7	Cast Line 3 Double Deck Exit Lower Conveyor #1	480	1			1	0.8	0.8											0								0	
165	7	Cast Line 3 Double Deck Exit Lower Conveyor #2	480	1			1	0.8	0.8											0								0	
166	7	Cast Line 3 Exit Elevator Hydraulic Unit Pump	480	50			50	0.8	40.0										1500	75								0	
167	7	Cast Line 3 Exit Elevator Hydraulic Unit Recirc Pump	480	3			3	0.8	2.4							15													
167A	6	Cast Line 1 Rollover Main Panel	480							100																			
167B	6	Cast Line 1 Rollover Index Table	480	5			5	0.8	4.0																				
167C	6	Cast Line 1 Rollover Hydraulic Motor #1	480	15			15	0.8	12.0																				
167D	6	Cast Line 1 Rollover Hydraulic Motor #2	480	15			15	0.8	12.0																				
167E	6	Cast Line 1 Rollover Recirc Pump	480	1			1	0.8	0.8																				
167F	6	Cast Line 1 EM Pump Preheat Oven	480	1			1	0.8	0.8																				
167G	6	Cast Line 1 EM Pump Cooling Fan Control Panel	480							176																			
167H	6	Cast Line 1 EM Pump Cooling Motor #1	480	1			1	0.8	0.8																				
167I	6	Cast Line 1 EM Pump Cooling Motor #2	480	1			1	0.8	0.8																				
167J	6	Cast Line 1 EM Pump Main Control Panel	480							700																			
168																													
169		ROBOTS																											
170		Cast Line 1 Core Package Insertion Robot (7600)	480			7.3	7.3	0.7	5.1	30										0			15	60	1/2 NPT			0	
171		Cast Line 1 Core Package Insertion Blow Off																		0		150		60	1 NPT			0	
172		Cast Line 1 Cover Insertion Robot (7600)	480			7.3	7.3	0.7	5.1	30										0			15	60	1/2 NPT			0	
173		Cast Line 1 Cover Insertion Blow Off																		0		150		60	1 NPT			0	
174		Cast Line 2 Core Package Insertion Robot (7600)	480			7.3	7.3	0.7	5.1	30										0			15	60	1/2 NPT			0	
175		Cast Line 2 Core Package Insertion Blow Off																		0		150		60	1 NPT			0	
176		Cast Line 2 Cover Insertion Robot (7600)	480			7.3	7.3	0.7	5.1	30										0			15	60	1/2 NPT			0	
177		Cast Line 2 Cover Insertion Blow Off																		0		150		60	1 NPT			0	
178		Cast Line 3 Core Package Insertion Robot (7600)	480			7.3	7.3	0.7	5.1	30										0			15	60	1/2 NPT			0	
179		Cast Line 3 Core Package Insertion Blow Off																		0		150		60	1 NPT			0	
180		Cast Line 3 Cover Insertion Robot (7600)	480			7.3	7.3	0.7	5.1	30										0			15	60	1/2 NPT			0	
181		Cast Line 3 Cover Insertion Blow Off																		0		150		60	1 NPT			0	
182																													
183																													
		TOTALS		1300.5	0.0	43.8	1344.3		1071.1			0.0		0.0	0.0	225.0				1125		1365	210						
	//for(int i=0 ; i< _cmsd->cells->size(); i++)
	//{
	//	Cell * c = (Cell *) _cmsd->cells->at(i).get();
	//	std::string name = (LPCSTR) c->name;
	//	CCellHandler *  _cellHandler = new CCellHandler((AgentMgr * ) this, c,&_cmsd);
	//	_cellHandlers.push_back(_cellHandler);
	//	for(int j=0; j< c-> resourceIds.size(); j++)
	//	{
	//		CResourceHandler * r  =  _cmsd.findResource((LPCSTR) c-> resourceIds[j]) ;
	//		if(r!=NULL)
	//			_cellHandler->_resources.push_back(r);
	//	}
	//}


		//ControlThread::Delay( 1.0 - ControlThread::threadtimer.elapsed());
//		for(int i=0 ; i<_resourceHandlers->size(); i++)
//		{
//			dUpdateWait=MIN(dUpdateWait, _resourceHandlers->at(i)->GetUpdateFactor());
////			OutputDebugString(StdStringFormat("Resource(%s) UpdateWait=%8.4f\n",_resourceHandlers->at(i)->_identifier.c_str(), dUpdateWait ).c_str())  ;
//		}
//		if(dUpdateWait > 1.0)
//			ControlThread::_dSpeedup = dUpdateWait;
//		else 
//			ControlThread::_dSpeedup=1.0;


// If job step done on resource 
	//	if( resource->_mttp<=0 && resource->currentJob!=NULL)
	//	{
	//		if(resource->outqueue.nMaxSize > 0 && resource->outqueue.CanPush())
	//		{
	//			resource->outqueue.Push(currentJob);
	//			currentJob=NULL;
	//		}
	//		// No outward queue so blocks if next step full
	//		else if(resource->outqueue.nMaxSize == 0)
	//		{
	//			at(i)->_currentstep++;
	//			CResourceHandler *  resource1 = resourceHandlers->FindResourceHandler(_current+1) ;
	//			if(resource1==NULL)
	//				continue;
	//		}

	//	}
	//	// revise current step in part from job
	//	_current = at(i)->_currentstep;
	//	if(_current>= at(i)->MaxStep())
	//		continue;	

	//	resource = resourceHandlers->FindResourceHandler(_current) ; 
	//	
	//	// Should push the next time...
	//	if(resource &&	resource->inqueue.nMaxSize > 0 && resource->inqueue.CanPush())
	//	{
	//		if(_current< 0 || _current>= at(i)->MaxStep()) 
	//		{
	//			DebugBreak();
	//		}
	//		resource->inqueue.Push(at(i));
	//	}
	//	else if( resource &&	resource->inqueue.nMaxSize == 0)
	//	{

	//		resource->currentJob = at(i);

	//	}

	How to get the attribute f a html file using IHTMLElement::getAttribute
I tried getting the attribute "name" in the following code( part of the html file) using IHTMLElement::getAttribute function

the function returns VARIANT* as the out parameter. couldn't find any documentation on VARIANT and i get assertion when i try to access the bstrVal of the VARIANT

here's the code i am using, can someone tell me 
1. what are the parameters i should pass to getAttribute function?
2. what is the flag parameter and what do i set it to?
3. is attribute matching case sensitive in this function

thanx
Shwetha


IDispatch* pDispatch = NULL;
HRESULT result = m_pBrowserApp->get_Document(&pDispatch);
if( result != S_OK)
{
pDispatch->Release();
return;
}
CComQIPtr&lt;IHTMLDocument2&gt; spBody(pDispatch);

IHTMLElementCollection* eCol;
result = spBody->get_all( &eCol);
if( result != S_OK)
{
eCol->Release();
pDispatch->Release();
return;;
}


long eleLen;
result = eCol->get_length(&eleLen);
if( result != S_OK)
{
eCol->Release();
pDispatch->Release();
return;
}

for( int i=0; i&lt;eleLen; i++)
{
VARIANT var2; 
VARIANT varIndex; 
varIndex.vt = VT_UINT; 
varIndex.lVal = i; 
VariantInit( &var2 ); 
IDispatch* pDisp; 
IHTMLElement* pEle;
VARIANT_BOOL pBool;
//	 BSTR bstr;

result = eCol->item(varIndex, var2, &pDisp); 
if( result != S_OK)
{
pEle->Release();
pDisp->Release();
continue;
}
result = pDisp->QueryInterface(IID_IHTMLElement, (void**)&pEle);
if( result != S_OK)
{
pEle->Release();
pDisp->Release();
continue;
}

pEle->get_isTextEdit( &pBool);
if( pBool )
{
VARIANT attr;
BSTR bstrtemp;
bstrtemp = SysAllocString(L"name");
result = pEle->getAttribute(bstrtemp, 1, &attr);
if( result != S_OK)
{
pEle->Release();
pDisp->Release();
continue;
}

bstrtemp = attr.bstrVal;	
CString attrValue = bstrtemp;	// &lt;-----------
//// gives a assertion failure here 
/// and the value of bstrtemp is NULL
}
pEle->Release();
pDisp->Release();
}

eCol->Release();
pDispatch->Release();


//LRESULT CMainFrame::DumpResourceHandlers()
//{	
//	for(int i=0 ; i<_resourceHandlers.size(); i++)
//	{
//		std::string dump= _resourceHandlers[i]-> ToString();
//		dump+= _resourceHandler-> GenerateReport();
//		OutputDebugString(dump.c_str());
//	}
//	return 0;
//}
//CResourceHandler::CResourceHandler(AgentConfiguration * agent, AgentMgr * config, Resource * r,  CCMSDIntegrator * cmsd) 
//{
//	_agent=agent;
//	_agentconfig=config;
//	_cmsd=cmsd;
//	_resource=r;
//	//	_nCurrentStep=-1;
//	job = NULL;
//
//	_statemachine = new CDESMonitor;
//
//
//}
//void CResourceHandler::Configure(crp::Config	& config, 
//							std::string identifier, 
//							std::string device, 
//							std::string xmldevice, 
//							std::string ipaddr,
//							std::string devicexmlpath)
//{
//	_config=config; 
//	_identifier=identifier;
//	_device =device;
//	_xmldevice =xmldevice; 
//	_ipaddr= ipaddr;
//	_devicexmlpath= devicexmlpath;
//	std::string filename = RecursiveFileFind(devicexmlpath, xmldevice + ".txt");;
//	_model= MTConnectDeviceParser().ReadDeviceDescription(filename);
//	_currentplan=NULL;
//	_statemachine = new CDESMonitor;
//}


	//CWtlHtmlView * pView = new CWtlHtmlView();
	//pView->Create(m_view,rcDefault,
	//	"about:blank", 
	//	WS_CHILD | WS_VISIBLE | WS_VSCROLL,
	//	WS_EX_CLIENTEDGE);
	//m_view.AddPage(pView->m_hWnd,fileDlg.m_szFileTitle);
	//_pages.push_back(pView);
	//GLogger.AddListener( boost::bind(&CMainFrame::LogMsg, this, _1));

		int	 FindResourceHandler(std::string id);
	void	 DumpJobs(CJobCommands * jobs);

void CMainFrame::DumpJobs(CJobCommands * jobs)
{
	std::string tmp;
	for(int i=0; i < jobs->size() ; i++)
	{
		tmp+=StdStringFormat("Job %s Part %s\n", jobs->at(i)->_jobId.c_str(), jobs->at(i)->_partid.c_str());
		int _current = jobs->at(i)->_currentstep;
		int j = FindResourceHandler(jobs->at(i)->_ResourceRequired[_current]);
		if(j<0) 
			continue;
		CResourceHandler * resource= _resourceHandlers[j];
		tmp+= resource->_statemachine->ToString();
	}
	OutputDebugString(tmp.c_str());
}

int CMainFrame::FindResourceHandler(std::string id)
{	
	for(int i=0 ; i<_resourceHandlers.size(); i++)
	{
		CResourceHandler *  _resourceHandler = _resourceHandlers[i];
		if(_resourceHandler->_identifier==id)
			return i;
	}
	return -1;
}


//class CJobHandler
//{
//public:
//	CJobHandler(AgentMgr * config, 
//		Job * job, 
//		CCMSDIntegrator * cmsd,
//		std::vector<CCellHandler * >	& cellHandlers)
//		: _cellHandlers(cellHandlers)
//	{
//		_agentconfig=config;
//		_job=job;
//		_cmsd=cmsd;
//		_cellHandlers=cellHandlers;
//	}
//	~CJobHandler(void){}
//
//	CJobHandler(std::vector<CCellHandler * >	& cellHandlers) : _cellHandlers(cellHandlers)
//	{
//	
//	}
//	void Init(Job * job);
//	std::vector<CCellHandler * >	&				_cellHandlers;
//	//std::vector<CJobCommand * > jobs;
//	CJobCommands jobs;
//
//	void Cycle();
//	void GenerateReport();
//	void CheckNewworkorder();
//	void CheckNewJob();
//
//	std::vector<ProcessPlan *> currentprocessplans;
//	int GetPartIndex(TCHAR * id)
//	{
//		for(int i=0; i< _job->partIds.size(); i++) 
//			if( _job->partIds[i] == _bstr_t(id)) 
//				return i;
//		return -1;
//	}
//
//
//	bool								_mRunning;
//	AgentMgr *				_agentconfig;
//	Job *								_job;
//	CCMSDIntegrator *					_cmsd;
//	boost::mutex						_access;
//
//	std::vector< std::string > parts;
//	std::vector< int > totnumparts;
//	std::vector< int > numparts, finishedparts;
//	std::vector<ProcessPlan*> _doneprocessplans;
//	std::vector<ProcessPlan*> _activeprocessplans;
//
//};
//class CPartHandler
//{
//public:
//	CPartHandler::CPartHandler(AgentMgr * config, Part * part, CCMSDIntegrator * cmsd)
//	{
//		_agentconfig=config;
//		_part=part;
//		_cmsd=cmsd;
//	}
//	~CPartHandler(void){}
//	void Cycle(){}
//
//	bool								_mRunning;
//	AgentMgr *							_agentconfig;
//	Part *								_part;
//	CCMSDIntegrator *					_cmsd;
//
//
//};
	//for(int i=0 ; i< job->partIds.size(); i++)
	//{
	//	std::string partid = job->partIds[i];
	//	try {
	//		// Find all resource and then MTP for each resource to make part
	//		Part * part = cmsd->FindPartById(partid);
	//		if(part==NULL)			throw std::exception("Bad part lookup in CJobCommands::InitAllJobs");
	//		ProcessPlan * processplan  = cmsd->FindProcessPlanById(part->processplanidentifier);
	//		if(processplan==NULL)			throw std::exception("Bad processplan lookup in CJobCommands::InitAllJobs");
	//		for(int j=0;j< 	processplan->steps.size(); j++)
	//		{
	//			Process *process = processplan->processes[j];
	//			Cell * cell= cmsd->FindCellById((LPCSTR)  process->resourcesRequired[0]);
	//			if(cell== NULL)			throw std::exception("Bad cell lookup in CJobCommands::InitAllJobs");

	//			Resource * r = cmsd->FindResourceById((LPCSTR) cell->resourceIds[0]);
	//			if(r== NULL)			throw std::exception("Bad Resource lookup in CJobCommands::InitAllJobs");
	//			CResourceHandler * ResourceHandler = _wndMain->_resourceHandlers.Find((LPCSTR) r->name);
	//			if(ResourceHandler==NULL)
	//				continue ;
	//			dOperationTimeForPart[i]+= ResourceHandler->_statemachine->MTTP;
	//		}
	//	} catch(std::exception err) { OutputDebugString(err.what()); } 
	//}

